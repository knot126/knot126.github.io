<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<meta name="keywords" content="knot126, core, library, melon, trestle, games, projects, website"/>
		<meta name="description" content="Melon is a software framework (or core library) specifically focused on being simple and well designed. It's a collection of helpful functions and data structures that are simple and easy to use."/>
		<title>Melon Core Library &mdash; Knot126</title>
		<link rel="icon" type="image/png" href="./favicon.png"/>
		<link rel="stylesheet" href="./common/main.css"/>
		<script src="./common/main.js"></script>
	</head>
	<body>
		<div id="container" class="page-container">
			<nav id="navbar" class="main-section navigation-section">
				<noscript><i>You need to enable JavaScript to load the navbar.</i></noscript>
			</nav>
			<script>main();</script>
			<div id="main" class="main-section content-section">
				<h1>Melon</h1>
				<p><b>Melon Core Library</b> is a software framework (or core library) specifically focused on being simple and as well designed as possible.</p>
				<p>This includes generic APIs for storage with basic access controls, graphical windowing (WIP) and multithreading (WIP); type generic variable containers, bitmaps (and soon vector graphics and 3D scenes), logging, random number generation, time utilities, strings, basic mathematics and 2D and 3D rendering (WIP) with even more coming soon.</p>
				<p>Currently, melon is being used in the <a href="./trestle.html">Trestle simulation and games engine</a>.</p>
				
				<h2>Style and design</h2>
				<p>I don't really like to commit to a single paradigm or philosiphy becuase it's mostly a bad idea. Why should you commit to "agile" and "worse is better" at the start when you barely have an idea of the project and your team? The best design will vary by project, purpose, people and many other factors.</p>
				
				<div class="box-section info">
					<p><b>Should a video game and nuclear power plant control software should use the same design principles?</b> I think they should not. With video games, it won't matter if you have a bug and it's not safety critical. In the other situation you might kill some people.</p>
					<p>Of course nuclear power plants (probably) have failsafes, but still, I imagine making swiss cheese with less holes is more important for safety crtitcal things than for video games.</p>
					<p>And at that I do think they can borrow some things from each other. While they are not the same situation, making abstract statements and observations can be helpful as long as you clearly know their constraints &mdash; which most people fail to realise.</p>
					<p>So overall I don't think there is one design that works well for everything. If there was Linux would be the only operating system ever used and we would only ever have one hashing function for everything.</p>
				</div>
				
				<p>That being said I think the <a href="https://en.wikipedia.org/wiki/Worse_is_better#Characteristics">MIT vs Worse is Better argument</a> is important for melon as a library, and I have commentary on it:</p>
				<ul>
					<li><b>Simplicity</b>: I really disagree with both. I think it's important to make the interface <i>intuitive</i>. It should feel natrual to use &mdash; after all, the point of an interface is for people to use it! This generally involves striking a balance between making a simple interface and a simple implementation.</li>
					<li><b>Correctness</b>: I personally prefer projects that favour the MIT approach, but this depends on the situation and what you're doing. Correctness is nice, but not always needed and is sometimes not possible within a given time frame. Additionally, keep in mind that I use "correctness" to mean "correct for my given constraints and what I want"; there is no "correct" without being relative to something. Whatever you do, clearly documenting and communicating the level of correctness and percision is going to be the most helpful thing you can do.</li>
					<li><b>Consistency</b>: Consistency is not something I feel qualified to speak about much. It's nice to make things more consistent, but a design that favours overall consistency over intuition will feel bland and unnatrual. At the same time, don't be like PHP and swap the haystack and needle between array and string functions. It can be fun in a way, but that's just largely annoying when you try to use it.</li>
					<li><b>Completeness</b>: I think it's sometimes okay to say "we won't handle an edge case" if you really don't need to, but don't underestimate the usefullness of quality of life features. The lack of something complete might lead to harder to understand code just to implement something that would be more intuitive if things were more complete earlier.</li>
				</ul>
				<p>Of course, this is just how I feel about the software that I design. It's attached to the kinds of projects I've done and it has a "feeling" assocaited with my projects. If you have something different and it works well for you, then that's okay! Diversity is good and might even lead to improvements for everyone.</p>
				<p>I should also note: this isn't absolute and I don't hold myself to it. You shouldn't either! I can change and you can be different. Design software the way you like.</p>
				
				<h2>What are we planning?</h2>
				<p>A large part of the core library is that it should implement most things without being invasive. The best way we can put it into words is that it should provide the <a href="https://upload.wikimedia.org/wikipedia/commons/3/32/Lego_Color_Bricks.jpg">building blocks</a> so that someone who knows what everything means can simpily put them together at a very high level.</p>
				<p>To help with this, we want to support things that make C programming "like the web" where there are readily-available, mostly easy to use APIs for everything.</p>
				<p>Right now, we are planning modules for <a href="https://en.wikipedia.org/wiki/Computer_algebra_system">computer algebra systems</a>, access to <a href="https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units">GPU compute</a>, advanced geometry and 3D scene access, (mathematical) <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graphs</a>, a resource manager, a main loop handler, cryptography things (cryptographic primitives; encryption and signing), networking (sockets) support with HTTP helpers, <a href="https://en.wikipedia.org/wiki/Vector_graphics">vector graphics</a> and compression algorithms, with everything essentially written from scratch.</p>
				<p>That is already quite a lot, and since it is meant to be a proper educational exprience, it may take a long time or be flaky in some areas, but that is okay!</p>
				
				<h4>But doesn't building blocks just encourage people to not understand what lies underneath the abstraction and make programmers clash blocks until they work?</h4>
				<p>Well, sometimes yes. For everyone <i>except for us</i>. And we're writing this library for us, and not anyone else. :)</p>
				<p>Of course, you are still welcome to use it anywhere you like.</p>
				
				<h2>Source code</h2>
				<div class="card-section">
					<h3><a href="https://github.com/knot126/Melon">View on Github</a></h3>
					<p>View the Melon source code on Github!</p>
				</div>
			</div>
			<div id="main" class="main-section disclaimer-section">
				<p>This website is Copyright &#169; 2020 &mdash; 2023 Knot126</p>
			</div>
		</div>
	</body>
</html>
